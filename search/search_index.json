{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Syllabus","text":"<p>NB: THIS IS A MOCK SITE FOR A TEACHING DEMONSTRATION</p>"},{"location":"#data-structures-and-algorithms-csci-232","title":"Data Structures and Algorithms (CSCI 232)","text":"<ul> <li>Term: Spring 2025</li> <li>Department: Computer Science</li> <li>Instructor:  Isaac Overcast (iao2122@columbia.edu, he/him)</li> <li>Location: University Hall 210</li> <li>Day/Time: Monday March 24 (10-11am)</li> <li>Office hours: By request (email me)</li> </ul> <p>Bulletin: Advanced data structures and programming techniques and their  application. Topics include: trees, balanced trees, graphs, dictionaries, hash  tables, heaps. Examines the efficiency and correctness of algorithms. </p> <p>Organization: Each meeting will be a mix of lecture, in-class \"active\" learning,  and group activities. In addition a lot of work is assigned outside of class,  including assignments, reading, and watching video tutorials. An example session  would include a lecture to introduce a general concept with examples, followed  by a group active-learning exercise in which students implement code with pair-programming.</p> <p>Equipment: All software and materials for the course are open access (available online for free) including assigned readings and videos. Students will develop  code on their own computers, no matter if they are running Linux, Mac, Windows, or Chrome OS. This will require student to install free software on their computers.</p> <p>Assessment/Grades: Grades will not be curved. However, your grade will be assigned relative to the performance of your peers. The maximum grade will earn an A, and grades that are less than one-half of that maximum grade will be assigned an F. Between these values (max and \u00bd max) intervals equating to letter grades are divided equally. Grades are based on participation (attendance and discussions), assignments, projects proposals, and project presentations, and the final project. - 25% Participation - 35% Assignments - 20% Midterm exam - 20% Final exam</p> <p>Participation: In addition to attendance you are expected to contribute to discussions in class by asking questions, and to interact with your peers through breakout session code reviews. Participating in the CSCI 232 Discord Server also 'counts' as participation.</p> <p>Assignments: Code-based assignments are used to assess comprehension of new  concepts learned in class. These are graded on effort, accuracy, and style. </p> <p>Statement on use of generative AI in coursework: Students are not discouraged from using AI tools, such as ChatGPT or similar technologies, to support their learning and assignments. However, the use of AI must be acknowledged clearly in your submissions. For example, you can include a brief note stating, \"This analysis was generated with the assistance of [AI tool name].\"</p> <p>While AI can be a powerful resource, it is not infallible. These tools can occasionally produce incorrect or misleading information, and relying on them exclusively may hinder your ability to critically evaluate data, methods, and results. Therefore, you are expected to: - Verify Information: Cross-check AI-generated outputs against authoritative sources or class materials. - Develop Independent Skills: Engage with the concepts and tools independently to ensure you can identify when AI outputs are inaccurate or suboptimal. - Take Responsibility: Ultimately, you are accountable for the content and quality of your work, regardless of whether it was AI-assisted.</p> <p>By using AI judiciously and critically, you will enhance your ability to evaluate the reliability of data and tools, which is a vital skill in data science. This statement on the use of generative AI was generated with the assistance of ChatGPT.</p> <p>Statement of academic integrity: Academic dishonesty is a serious offense  and will not be tolerated in the class. Students are expected to reference  sources appropriately in any work. Students are allowed to discuss homework assignments but should respond to questions and tasks on their own, not using a group answer. Violation of the rules of academic integrity (e.g., plagiarizing materials) will result in automatic failure of the course. Rules and  consequences are outlined in the MSU Student Code of Conduct.</p>"},{"location":"lectures/revealjs/css/theme/","title":"Index","text":""},{"location":"lectures/revealjs/css/theme/#dependencies","title":"Dependencies","text":"<p>Themes are written using Sass to keep things modular and reduce the need for repeated selectors across files. Make sure that you have the reveal.js development environment installed before proceeding: https://revealjs.com/installation/#full-setup</p>"},{"location":"lectures/revealjs/css/theme/#creating-a-theme","title":"Creating a Theme","text":"<p>To create your own theme, start by duplicating a <code>.scss</code> file in /css/theme/source. It will be automatically compiled from Sass to CSS (see the gulpfile) when you run <code>npm run build -- css-themes</code>.</p> <p>Each theme file does four things in the following order:</p> <ol> <li> <p>Include /css/theme/template/mixins.scss Shared utility functions.</p> </li> <li> <p>Include /css/theme/template/settings.scss Declares a set of custom variables that the template file (step 4) expects. Can be overridden in step 3.</p> </li> <li> <p>Override This is where you override the default theme. Either by specifying variables (see settings.scss for reference) or by adding any selectors and styles you please.</p> </li> <li> <p>Include /css/theme/template/theme.scss The template theme file which will generate final CSS output based on the currently defined variables.</p> </li> </ol>"},{"location":"lectures/revealjs/examples/markdown/","title":"Markdown Demo","text":""},{"location":"lectures/revealjs/examples/markdown/#external-11","title":"External 1.1","text":"<p>Content 1.1</p> <p>Note: This will only appear in the speaker notes window.</p>"},{"location":"lectures/revealjs/examples/markdown/#external-12","title":"External 1.2","text":"<p>Content 1.2</p>"},{"location":"lectures/revealjs/examples/markdown/#external-2","title":"External 2","text":"<p>Content 2.1</p>"},{"location":"lectures/revealjs/examples/markdown/#external-31","title":"External 3.1","text":"<p>Content 3.1</p>"},{"location":"lectures/revealjs/examples/markdown/#external-32","title":"External 3.2","text":"<p>Content 3.2</p>"},{"location":"lectures/revealjs/examples/markdown/#external-33-image","title":"External 3.3 (Image)","text":""},{"location":"lectures/revealjs/examples/markdown/#external-34-math","title":"External 3.4 (Math)","text":"<p><code>\\[ J(\\theta_0,\\theta_1) = \\sum_{i=0} \\]</code></p>"},{"location":"lectures/revealjs/test/simple/","title":"Simple","text":""},{"location":"lectures/revealjs/test/simple/#slide-11","title":"Slide 1.1","text":"<pre><code>var a = 1;\n</code></pre>"},{"location":"lectures/revealjs/test/simple/#slide-12","title":"Slide 1.2","text":""},{"location":"lectures/revealjs/test/simple/#slide-2","title":"Slide 2","text":""},{"location":"pages/devnotes/","title":"Course website dev notes","text":"<p>All course materials live in my a github repository: https://github.com/isaacovercast/CSCI232</p>"},{"location":"pages/devnotes/#building-this-website","title":"Building this website","text":"<p>Install mkdocs-material into your current environment. <pre><code>conda install mkdocs-material -c conda-forge\n</code></pre></p> <p>Move into the repo directory alongside mkdocs.yml and build locally with <code>mkdocs</code>.  Changes to the repo will now automatically update in the website being served to localhost:8000.  <pre><code>mkdocs serve\n</code></pre></p>"},{"location":"pages/devnotes/#other-good-online-dsa-materials","title":"Other good online DS&amp;A materials","text":"<ul> <li>Crafting Interpreters - Hash Tables (Nystrom): This is actually quite a nice and thorough but still accessible  textbook-like approach to the subject (uses C for the example code). This is actually  a really nice and modern treatment. It's part of a book about programming language  design, so too bad it is not from a  DS&amp;A book. Could be a good opportunity to follow  this lead and do a whole DS&amp;A book in this style.</li> <li>Visualgo Hash table: A direct link to all the text contained in the E-Learning interactive part of this page, very concise, good details but terse.</li> <li>Grokking Algorithms (Bhargava): This is a very fun and accessible book about algorithms that uses drawings and a conversational style to illustrate concepts. It's really fun to read, maybe a little 'light' overall, but students might like it.</li> </ul>"},{"location":"pages/devnotes/#dsa-in-python","title":"DS&amp;A in python","text":"<ul> <li>A nice list of phython DS&amp;A books</li> <li>Data Structures and Algorithms in Python by Goodrich, Tamassia, &amp; Goldwasser pdf: Seems like a pretty solid and standard DS&amp;A book. Hash table description starts on page 410.</li> <li>Fundamentals of python: Data Structures by Lambert</li> <li>Data Structures and Algorithms with Python (Springer 2014): Pretty old fashioned.</li> <li>Data Structures and Algorithms (github): A textbook-like collection of python code implementing several different data structures. Not comprehensive.</li> </ul>"},{"location":"pages/devnotes/#dsa-in-rust","title":"DS&amp;A in rust","text":"<p>Both of these are freely available online in github repositories</p> <ul> <li>Hands on data structures and algorithms with rust</li> <li>Rust book</li> </ul>"},{"location":"pages/devnotes/#hash-table-visualizations","title":"Hash table visualizations","text":"<ul> <li>Visualgo Hashtable: Very fancy. Has a built in lesson that is quite extensive. Exploration mode is excellent. Developed by National Univ. Singapore. A huge amount of other data structures are covered with similarly cool visualization. Worth looking at.</li> <li>Open Hashing (SF State): Implements mod 13 hashing, it's cool but you have to add one element at a time by hand, maybe useful.</li> <li>Hashing Visualization (ACM): Can choose your hash function and collision resolution policy, maybe good for illustrating linear probing. Has a bunch of other stuff not covered in the book.</li> <li>Virtual Labs - Hash Tables: Less a visualization platform and more of a self-guided learning platform (developed by the Ministry of Education of the Government of India, wow!). It actually does have some interactive parts under the 'Practice' left-navs.</li> </ul>"},{"location":"pages/devnotes/#getting-java-working-with-jupyter-notebooks","title":"Getting Java working with Jupyter notebooks","text":"<p>It turns out there are not too many options for running java kernels in jupyter. I messed with this for a long time and never got satisfactory results, mostly because I wanted students to do some easy plotting and this is impossible in Java.  I did get a java jupyter kernel working though, with some trial and error:</p> <ul> <li>IJava: I ended up using this because it was simple to install (<code>conda install -c conda-forge ijava</code>) and it seemed to 'work', but it has few features and is not actively maintained.</li> <li>awesome-jupyter-java maintains a list of kernels (both active and inactive)</li> <li>Kotlin-jupyter seems promising, as kotlin is designed to be backwards compatible with java, so the algs4 code should work, and also it could give access to more plotting functionality.</li> <li>ganymede &amp; rapaio also both seemed promising, but supported by individuals so maybe not robust in the long term.</li> <li>The JetBrains team maintains a lets-plot implementation which works with Kotlin, and theoretically could work in jupyter notebooks but I never got that far.</li> </ul>"},{"location":"pages/devnotes/#materials-from-past-courses","title":"Materials from past courses","text":"<ul> <li>CSCI 232 Spring 2024 - Syllabus</li> <li>CSCI 232 Spring 2024 - Class Schedule</li> <li>CSCI 232 Fall 2021</li> <li>Lucy's course materials are all layed out nicely in github pages</li> </ul>"},{"location":"pages/devnotes/#materials-from-uiuc-cs-courses","title":"Materials from UIUC CS courses","text":"<p>The Grainger College of Engineering has a massive CS program and all their course materials are standardized and available on their  website. It is a treasure trove of useful resources!</p> <ul> <li>CS225 Data Structures</li> <li>CS 277 Algo &amp; Data Stru for Data Sci</li> </ul>"},{"location":"pages/devnotes/#visualgo-cheat-sheet","title":"VisuAlgo Cheat-sheet","text":"<p>Insert items to generate separate chaining in the text:  </p> <p>90, 80, 51, 71, 62, 52, 2, 42, 53, 44, 24, 14, 45, 85, 15, 26, 56, 67, 17, 18</p> <p>Items to generate Linear probing in the text:</p> <p>91, 84, 19, 59, 99</p>"},{"location":"sessions/BLANK-session-skel/","title":"Session 9","text":""},{"location":"sessions/BLANK-session-skel/#icebreaker-question","title":"Icebreaker question","text":"<ul> <li>TODO</li> </ul>"},{"location":"sessions/BLANK-session-skel/#learning-objectives","title":"Learning objectives","text":"<p>In this session we will learn about.... By the end of this session you will  be more familiar with the following topics:</p> <ul> <li>XXX</li> <li>XXX</li> </ul>"},{"location":"sessions/BLANK-session-skel/#review-and-discussion","title":"Review and Discussion","text":"<ul> <li>Review homework assignments</li> </ul>"},{"location":"sessions/BLANK-session-skel/#in-class-exercises","title":"In class exercises","text":"<ul> <li>TODO Link to Lecture XX slides </li> </ul>"},{"location":"sessions/BLANK-session-skel/#assignments","title":"Assignments","text":"<ul> <li>TODO Readings</li> <li>TODO Tutorials </li> </ul>"},{"location":"sessions/session-1/","title":"Session 1 - Hash Tables","text":""},{"location":"sessions/session-1/#icebreaker-question","title":"Icebreaker question","text":"<p>If you could magically change one annoying thing about coding forever, what would it be?</p> Icebreaker results"},{"location":"sessions/session-1/#learning-objectives","title":"Learning objectives","text":"<p>In this session of class we will learn about hash tables, an efficient data structure for mapping key/value pairs. By the end of this session  you will be more familiar with the following topics:</p> <ul> <li>Hash tables: A practical &amp; efficient data structure for storing key/value pairs</li> <li>Hash functions for mapping keys to integer values</li> <li>Useful hash function properties: Determinism, efficiency, &amp; uniformity of hashes</li> <li>Collision-handling schemes: Separate chaining &amp; Linear probing</li> <li>Load factor &amp; hash table resizing</li> </ul>"},{"location":"sessions/session-1/#in-class-exercises","title":"In class exercises","text":"<ul> <li>Why don't we just ask ChatGPT to explain hash tables to us? It seems easier that way, and maybe then you won't need me anymore. </li> <li>Lecture 1: Introduction to hash tables</li> <li>Tutorial 1.0: Hash Table Excercises (jupyter notebook)</li> <li>Tutorial 1.1: Interactive Hash Table Exploration</li> </ul>"},{"location":"sessions/session-1/#assignments","title":"Assignments","text":"<ul> <li>Implement hash table classes in python for each of the collision resolution strategies we discussed today: and <code>HashTableChaining</code> for separate chaining;  and <code>HashTableProbing</code> for linear probing. Add them to a <code>hash_tables.py</code> file in the <code>data_structures</code> module of your CSCI232 github repo, and  commit/push the changes when they are complete. </li> <li>Read Chapter 12 \"Sorting and Selection\" in Data Structures and Algorithms in Python by Goodrich, Tamassia &amp; Goldwasser (pdf)</li> <li>Watch the video 15 sorting Algorithms in 6 minutes<ul> <li><sup><sub>Most visually satisfying: Merge sort</sub></sup></li> <li><sup><sub>Most intellectually satisfying: Bogosort</sub></sup></li> </ul> </li> </ul>"},{"location":"tutorials/1.0-hash-table-experiments/","title":"Hash Table Exercises (jupyter notebook)","text":""},{"location":"tutorials/1.0-hash-table-experiments/#learning-objectives","title":"Learning objectives","text":"<p>By the end of this session you should: - Have a good working understanding hashing - Be able to articulate the need for determinism, efficiency, &amp; uniformity in a good hash function</p>"},{"location":"tutorials/1.0-hash-table-experiments/#launch-the-csci-232-repo-in-binder","title":"Launch the CSCI 232 repo in binder","text":"<p>This activity is stored in our class github repository  as a jupyter notebook. The easiest way to interactively manipulate this notebook is by launching our github repo in using Binder, a cloud based service for sharing reproducible interactive computing environments from github repos.</p> <p>In practice, Binder is great for one-off sessions like workshops (or teaching demonstrations). However, in a real classroom environment the students would almost certainly have cloned the class repo and be launching and running these notebooks on their local machines. For this exercise you can launch the github repo in Binder by opening this link in a new tab:</p> <p></p> <p>After your Binder instance spins up (it could take a few seconds or a few minutes depending on if it has been launched and cached recently), it will drop you into the Jupyter Lab interface, with a file browser on the left, and the Launcher in the main panel.</p> <p></p> <p>In the leftnav open the notebooks directory, and then open (by double-clicking) <code>nb-1.1-hash-table-experiments.ipynb</code>, this will launch the notebook for  this exercise in the main panel, and you may proceed to follow the rest  of the tutorial that it contains.</p>"},{"location":"tutorials/1.1-interactive-hash-tables/","title":"Interactive hash table exploration","text":""},{"location":"tutorials/1.1-interactive-hash-tables/#learning-objectives","title":"Learning objectives","text":"<p>By the end of this session you will develop experience with:  </p> <ul> <li>Understanding two basic hash table collision resolution strategies<ul> <li>Separate chaining  </li> <li>Linear probing  </li> </ul> </li> <li>Inserting, removing, and searching hash tables of these types  </li> <li>Understaning load factor and how it is calculated</li> </ul>"},{"location":"tutorials/1.1-interactive-hash-tables/#launch-the-visualgo-hash-table-exploration-tool","title":"Launch the VisuAlgo hash table exploration tool","text":"<p>Visualgo is a wonderful, interactive, online tool for understanding the structure and functioning of numerous common data structures and algorithms using intuitive visualizations.</p> <p>Launch the hash table explorer in a new tab (right click and 'Open Link in New Tab').</p>"},{"location":"tutorials/1.1-interactive-hash-tables/#separate-chaining","title":"Separate Chaining","text":"<p>Upon launching VisuAlgo you'll be dropped into the Separate Chaining 'e-Lecture Mode'. You can exit this mode and enter 'Exploration Mode' by simply clicking anywhere in the window outside the explanatory dialogue pop-up. By default, it will populate the window with a new Hash Table with random values for number of 'buckets' (<code>M</code>), and a random number of items (<code>N</code>). Let's start by creating a new Hash Table with the same number of buckets and items so we can all be looking at the same thing.</p> <p>In the lower left there is a panel for applying different functions to the simulation. Choose <code>Create(M, N)</code>. Set <code>M</code> = 10 and <code>N</code> = 20, and push Go. The interface will populate a new 10 bucket hash table with 20 random integer values. Because we are so used to counting in base 10, it's easy to see that the compression function being used is simply <code>mod M</code> (the least significant digit of each key equals the index of the bucket it is stored in).</p> <p>After you create a new Separate Chaining hash table you should see something like this, an array of buckets indexed 0-9, and a linked list of items within  each bucket. </p> Hint: Steps to follow exactly the figures in the tutorial. If you prefer to follow exactly the example in this tutorial you can do this:  - `Create(M, N)` and set `M` = 10 and `N` = 0  - `Insert(v)` and copy/paste these values: 90, 80, 51, 71, 62, 52, 2, 42, 53, 44, 24, 14, 45, 85, 15, 26, 56, 67, 17, 18  <p> Secondary containers of Separate Chaining Hash Tables</p> <p> In this instance, the VisuAlgo team has decided to implement the separate chaining buckets as doubly-linked lists, which is smart because it means  adding and removing items from the hash table will be really fast. This is  a design decision which isn't always used, and which has complexity/performance tradeoffs which we will discuss further. </p>"},{"location":"tutorials/1.1-interactive-hash-tables/#separate-chaining-search","title":"Separate Chaining Search","text":"<p>Pick the bucket in your simulation with the longest list of items and find the last item in this list. Let's say we want to find this item in our hash  table, how does the search algorithm work in this case.</p> <p>In my example, the 'deepest' item is 42 (I did not do this on purpose, I swear it was random), so in the leftnav I will choose <code>Search(v)</code>, enter 42 in the  text field, and push Go. Here you will see an animation of the search  process, where first the algorithm determines the correct bucket  (<code>42 mod 10</code>). Finding this bucket full, it proceeds to walk down the list  until it finds the item of interest.</p> <p></p>"},{"location":"tutorials/1.1-interactive-hash-tables/#separate-chaining-insert","title":"Separate Chaining Insert","text":"<p>Insertion for Separate Chaining (in this implementation) does something interesting. It first identifies the correct bucket with <code>mod</code>, and then it simply appends the item to the doubly-linked list in this bucket (using the tail  pointer of the first item). Choose a value that does not already appear in  the bucket you have been manipulating (I will choose 12). On the leftnav select  <code>Insert(v)</code> and enter 12 (or whatever you choose).</p> <p></p> <p> Discussion Item</p> <p> I said this behavior is interesting, so what might be interesting about it? What are the consequences of this 'blind' tail insertion? What happens if  you try to insert this same item again? What are the benefits of this design choice  and why might this not be 'optimal' behavior? </p>"},{"location":"tutorials/1.1-interactive-hash-tables/#separate-chaining-remove","title":"Separate Chaining Remove","text":"<p>Stick with the bucket in your hash table with the most items (the one we have been using so far) and pick an item in the bucket that you want to remove (I'll remove 42). In  the lower-left open the function pane and choose  <code>Remove(v)</code>, enter 42, and push Go. You'll see the animation of the algorithm that defines item removal.</p> <p></p> <p>Try removing an item that doesn't exit (I will try to remove 42 again). In  this case you can see the algorithm finds the appropriate bucket, and then  walks the list searching for the item to remove. Not finding it, the program informs you the item is not found in the hash table and quits. At this point, in a python program it would throw a <code>KeyError</code> which you would have to handle somehow (or not).</p> <p> </p>"},{"location":"tutorials/1.1-interactive-hash-tables/#separate-chaining-load-factor","title":"Separate Chaining Load Factor","text":"<p>The VisuAlgo interface also does a nice thing in automatically calculating and presenting the Load Factor of this hash table. Recall from the reading that load factor is defined as the average number of items per bucket (more specifically it is the ratio of the total number of items in the hash  table divided by the length of the bucket array). In VisuAlgo this is  denoted as \u03b1 with \u03b1 = N/M.</p> <p> On differences in notation</p> <p> Notice that our reading uses slightly different notation (\u03bb =  n/N), where \u03bb is load factor, n is number  of items, and N is number of buckets. The notation is different but  the equation is identical in meaning. </p> <p>Create a new separate chaining hash table with <code>M</code> = 10 and <code>N</code> = 40. This is a very 'full' hash table. As you will recall from the reading, core hash table functions (insert/delete/search) degrade in performance as a function of \u03b1 (i.e. they run with O(\u03b1) on average). Our text suggest that \u03b1 &lt; 0.9 is optimal for hash tables with separate chaining.</p> <p></p> <p>One of the features of separate chaining hash tables is that they are still capable of operating (though with reduced performance) when \u03b1 &gt; 1. This is not the case for all collision resolutions schemes, particularly Linear Probing (though it has its own advantages).</p>"},{"location":"tutorials/1.1-interactive-hash-tables/#linear-probing","title":"Linear Probing","text":"<p>Now we will turn to a different collision resolution scheme: Linear Probing. In the top-nav click on LP, and this will switch you to the linear probing exploration mode. Just like before, there are probably lots of buckets in the default view, so choose <code>Create(M, N)</code> and set <code>M</code> = 10 and <code>N</code> = 5.</p> <p>After you create a new Linear Probing hash table you should see something like this, an array of buckets indexed 0-9, with 5 of the buckets occupied. </p> Hint: Steps to follow exactly the figures in the tutorial. If you prefer to follow exactly the example in this tutorial you can do this:  - `Create(M, N)` and set `M` = 10 and `N` = 0  - `Insert(v)` and copy/paste these values: 91, 84, 19, 59, 99  <p>There are two things to notice here: First, is that there are no secondary data structures with linear probing, it is organized as a flat  array; and second is that some of the items appear to be in their 'proper' bucket with respect to <code>mod 10</code>(e.g. 84) whereas others are in buckets which  at first glance appear to be 'wrong' (e.g. item 99 in bucket 2). In fact,  these two properties are very much related and are at the core of the collision resolution mechanism of this data structure. Let's try to get  some insight into linear probing by searching for item 99, to try to figure  out how it ended up in bucket 2.</p>"},{"location":"tutorials/1.1-interactive-hash-tables/#linear-probing-search","title":"Linear Probing Search","text":"<p>In the leftnav choose <code>Search(v)</code>, type 99, and press Go (you should choose a key that appears 'misplaced' in your own hash table). You will now see an animation that illustrates the algorithm probing for the input key in a linear fashion when it is not found in the expected bucket (in this case bucket 9). </p> <p>Not finding 99 in bucket 9, the algorithm 'wraps' to bucket 0 which is full but not with 99, continues to bucket 1 which is also full with not-99, and then finding 99 in bucket 2 it happily returns this value (or should).</p>"},{"location":"tutorials/1.1-interactive-hash-tables/#ooops","title":"Ooops!","text":"<p>Here is a good example of \"your instructor isn't always right\". The VisuAlg hash table simulator correctly locates key 99 in the 2nd bucket, but the interface tells us that this key wasn't found. Somebody should inform the developers! </p> <p> </p>"},{"location":"tutorials/1.1-interactive-hash-tables/#linear-probing-insert","title":"Linear Probing Insert","text":"<p>So we are getting a sense of the mechanism of linear probing and we might condense it's behavior into a verbal algorithm: 'If the bucket I want is  full check the next one; rinse and repeat'. Let's try to interogate our  understanding of this by inserting a new item. As a reminder, here is the current state of my hash table:</p> <p></p> <p>Pick an occupied bucket in your hash table with lots of consecutively  occupied buckets downstream from it. Choose an integer value that will <code>mod</code> to fill this chosen bucket. Now, look at the current state of the hash table and try to predict which bucket this new item will go into. In this example I  will choose an integer that mods to 0, so how about 0. </p> <p>Here is my result after inserting 0: </p> <p>For yourself, choose <code>Insert(v)</code> and do something similar for your own hash  table and you'll see the process the insertion algorithm takes to first check  the nth bucket (which your chosen integer should <code>mod</code> to), and then  to consecutively probe each subsequent bucket until it finds an empty one.</p>"},{"location":"tutorials/1.1-interactive-hash-tables/#linear-probing-remove","title":"Linear Probing Remove","text":"<p>Linear probing hash tables have to do a bit more work to maintain a consistent state when items are removed. Unlike separate chaining, you can't just remove an item and forget about it, because the position that the item is in might not be the exact bucket that it belongs in, but rather it may have landed 'downstream' from its true home because of intervening occupied buckets. This has consequences for searching which we will return to momentarily. One mechanism for handling this is to insert a special marker to denote 'available but formerly occupied' buckets (from your reading on page 419).</p> <p>I want to remove an item that has been inserted by probing (not in its  'correct' bucket), so I'll choose 59 (which is currently in the 0th bucket).  In the lower-left open the function pane and choose <code>Remove(v)</code>, enter 59, and click GO. You'll see the algorithm check the 9th bucket, and wrap around to  the 0th before it finds the correct item to remove.</p> <p></p> <p>VisuAlg denotes deleted but available buckets with the DEL marker.  Let's see how it handles searching and inserting with this pseudo-vacant bucket.</p> <p>For me, I will now try searching for 99 (in the 2nd bucket). I want the search algorithm to 'skip over' the DEL bucket in the search because it's available  but formerly occupied, and indeed this is what happens.</p> <p></p> <p>Now lets try to insert a value that we expect will land in the 0th bucket. If I choose to insert 29, think to yourself where this item will land in  the hash table. Let's try it.</p> <p></p> <p>To maintain consistency DEL is skipped over for searches, but not for insert operations! 29 lands in the first available bucket downstream from bucket 9, which is the vacant 0 bucket in this case. It's all quite clever!</p> <p>One last experiment is to try removing an item that doesn't exit. For me lets  try to remove 92, the 2nd bucket (where 92 'belongs') is full and there  several full buckets downstream so it should be interesting. (NB: Like  <code>search</code>, <code>remove</code> should also skip DEL buckets, but we don't validate  this behavior here).</p> <p></p> <p>At first you can see the expected behavior, that it checks bucket 2 and, not  finding the target value, begins probing downstream buckets. When it reaches the first empty bucket (in this case 5), it stops and returns '92 not found'. It might at first seem counterintuitive that the algorithm would not have to 'check' all buckets (just in case?), but in fact the organization of this data structure is such that if 92 is in the hash table, it is guaranteed to be discoverable by the method of linear probing before an empty bucket is reached. Magic.</p>"},{"location":"tutorials/1.1-interactive-hash-tables/#linear-probing-load-factor","title":"Linear Probing Load Factor","text":"<p>The VisuAlgo interface is still showing us the load factor (\u03b1), which I am sure you can see for the linear probing hash table we have been  manipulating is now 0.6. Linear probing hash tables are constraind to a  maximum of \u03b1 = 1, and perfomance begins to degrade with \u03b1 &gt; ~0.5. The python <code>dict</code> class implements a hash table with linear probing and the \u03b1 that it maintains will be an exercise we will investigate in a future tutorial.</p>"},{"location":"tutorials/1.1-interactive-hash-tables/#free-play-with-fuzzing","title":"Free Play with Fuzzing","text":"<p>Here comes my favorite part of being a computer scientist: To learn a new tool and then to figure out how I can break it! This is not wanton destructivism, we can actually learn a lot about how a tool works by  studying edge cases and boundary conditions. Edge cases and boundary  conditions can be pretty much anything you think the programmers who designed this interface did not anticipate as acceptable input. Think about the 'expected' input values and try to nudge these in different directions. If a function wants a number, give it a string, give it a negative number, give it a really  big number, how about a float? Push the boundaries and you'll see better how the tool behaves. In specific, here what you will mostly be learning about is the behavior of the Hash Table data structure as implemented by VisuAlgo, but this mindest of what is sometimes called  'fuzzing' is applicable everywhere,  and it's fun!</p> <p>Challenge: Spend a few minutes testing edge cases and see if you can find  any interesting behavior of the VisuAlgo hash table implementations to  report back to the class.</p>"}]}